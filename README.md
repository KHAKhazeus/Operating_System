# 电梯调度实验——设计方案报告

1750114 程子鸣

[TOC]

## 开发环境

​	考虑到应用的美观性与兼容性，在编写源码后编译得到程序能在多个平台上运用的初步开发手段有java, 使用qt的c++与网页。再考虑到，网页的控件丰富，部署简单，并且稍加修饰可以呈现出非常美观的界面，因此此实验我采用网页开发技术来实现。

​	本实验代码基于Bootstrapvue, anime.js实现：

- vue对于控件数据的绑定来说处理非常简单，能够简化开发流程中一些冗余的重复操作。在vue-cli的支持下，我能很好的进行框架式的网络开发，将网页组件化，使得开发逻辑更加清晰。
- Bootstrap自带的网格系统能帮助我更快地构建网页的界面并且bootstrap中也预先定义了一些组件，如按钮的样式，使得页面更加美观。
- Anime.js 能够帮助我实现电梯移动等动画，并且anime.js库动画具有并发性，很好地满足了电梯调度与移动的并发性要求。



​	为了便于调试与查看使用，我已经在github pages上部署了该项目的最终网页成果，链接如下：

​	https://khakhazeus.github.io/Operating_System/

​	

## 源码使用说明

本项目由 vue-cli 服务创建并使用npm进行包管理，请务必安装最新版本的node.js, npm与vue-cli后进行使用。

### 源码使用

```
npm install
```

####Compiles and hot-reloads for development

```
npm run serve
```

####Compiles and minifies for production

```
npm run build
```



### 直接浏览

https://khakhazeus.github.io/Operating_System/



## 界面说明

### 外部按键

![image-20190512185128190](/Users/kha/Library/Application Support/typora-user-images/image-20190512185128190.png)

​		外部按键的上半部分为每个楼层对应的外部按键，每个左侧为上，右侧为下。

​		Reload按钮是为报警恢复而设计。

​		外部按键下方的黑屏幕为每个楼层都有的外部电梯指示屏，对于每一组来说，最上面为电梯的标号，下面则是电梯所在的楼层，下面两个优点透明的上下箭头会用来标识当前电梯运行状态。

​		

**注：实际上1楼和20楼应该只有一个按键，但是为了美观性，还是保留了两个按键的设计**



###内部按键

![image-20190512185948657](/Users/kha/Library/Application Support/typora-user-images/image-20190512185948657.png)

​		内部按键一共有如下这些按钮，首先是开门与关门键，接下来则是内部的楼层按键用来发出到达请求。



### 电梯展示

![image-20190512191320982](/Users/kha/Library/Application Support/typora-user-images/image-20190512191320982.png)

​		电梯内部按键左侧为电梯井，用来直观地展示电梯的运行状态



### 电梯内部状态展示

![image-20190512191404785](/Users/kha/Library/Application Support/typora-user-images/image-20190512191404785.png)

​		这个是电梯内部的状态展示，工作原理与外部的状态展示类似。



## 设计分析

### 综述

​		对于电梯调度问题来说，有两大方面的问题需要解决，我把它们分别叫做：内部调度问题与外部调度问题。

​	    对于外部调度问题：

- 首先需要解决在某一楼层电梯外部的人按下上梯请求时，该请求应该分配给哪个电梯响应。
- 其次外部调度问题存在最优性的问题，由于实际场景中往往无法预知未来的调度请求，因此在此处我们将要求降低为局部最优。
- 外部调度还需要解决饥饿问题，但在电梯调度问题中，调度的方向只有两个，电梯有五座，并且同一调度方向的到达与上梯请求之间不存在互斥（顺路可以相应一些请求），因此饥饿出现的可能性比较小。

​		对于内部调度问题，需要解决在电梯载人后，内部按钮按下对应楼层之后发出的到达请求。对于这些请求可能出现如下情况需要解决，我根据电梯的状态对它们进行划分：

- 电梯目前没有行驶，收到新请求后处理新请求
- 电梯目前在行驶，收到新的同一行驶方向上的到达请求后，需要将该到达请求的楼层加入停靠目标之中
- 电梯目前在行驶，收到新的不同行驶方向上的到达请求后，不能让该到达请求抢夺目前行驶方向，但仍要在未来能够得到相应。

​        另外，对于内部与外部调度来说，都存在一个共同问题。对于所有新请求，我们还需要判断是否存在请求滥用的情况，如果等价的请求反复出现，程序需要对它们进行适当的处理。

​		除这两大部分之外，还有一些特殊的功能我在这里将进行说明：

- 警报键：当警报键被摁下时，电梯仍会继续尝试执行剩下的操作，在到达停止状态的时候，电梯会产生明显的变化以显示该电梯正在发出警报，按键会失效，以等待警察或技术人员的到来。取消警报需要按下RELOAD键进行重载。
- 开门与关门：由于开关门在运行过程中绝对不能有相应，并且在运行过程中电梯也会自动地开门与关门，因此，开关门键我设计为，在静止不动的状态下能够改变开关门的状态。
- 下客与上客：为了展示楼梯抵达指定楼层，到达指定楼层之后会开门之后关门，接下来电梯会继续执行还未得到相应的请求。

​		基于这些分析，我们将进一步对调度问题进行设计与分析。



### 整体构架

​		对于电梯调度问题，我采用了两个请求池来解决这个这个问题。![未命名文件 (1)](/Users/kha/Downloads/未命名文件 (1).png)

​		对于外部的请求来说，我分清是外部的上梯请求还是内部的到达请求，到达请求直接加入对应的电梯内部请求池中。对于上梯请求，我先将它加入外部请求池中，之后在5部电梯之间比较，寻找一个较优的匹配(距离近)，再将它加入对应电梯的内部请求池中。

​		对于内部请求池，电梯会根据自己的运行方向和状态来对目标进行过滤或者重新选择，最后生成一个当前时刻的目标队列并依照此队列进行执行。



### 外部请求池分配

![未命名文件 (2)](/Users/kha/Downloads/未命名文件 (2).png)

​		外部请求池分配规则如上图所示，实际实现该流程时有如下几个问题：

1. 该如何遍历各个电梯：

   和SCAN算法与C-SCAN算法的区别相似，如果每次遍历电梯都从第一个开始遍历，则隔一段时间发出的请求大多会集中在第一个电梯身上。**在我的实现当中，我采用了这样的做法**。还有一种做法是，每次遍历都从上次回应请求的位置开始遍历，这样分配会更加均匀。

2. 顺路与空闲电梯的遍历顺序：

   **我选择先遍历顺路的电梯，这样效率更高，并且能够空余其他电梯来相应其他的请求。**也可以先遍历空闲电梯，但这样会使得电梯全占用的可能性增加，会增加一些请求的等待时间。



### 运行方向过滤

![未命名文件 (3)](/Users/kha/Downloads/未命名文件 (3).png)

​		运行方向的过滤与电梯一次行动的流程图如上，每次结束一个流程之后，每个电梯会自动启动下一个流程，无限循环，直到电梯出现故障。



### 电梯状态迁移图

![未命名文件 (4)](/Users/kha/Downloads/未命名文件 (4).png)

